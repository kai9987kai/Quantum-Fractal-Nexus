<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum-Fractal Nexus - Next Level</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="/manifest.json">
  <link rel="shortcut icon" href="assets/images/2019-11-4-128x128.jpg" type="image/x-icon">
  
  <!-- External Libraries -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://apis.google.com/js/api:client.js"></script>
  
  <!-- Consolidated CSS -->
  <style>
    /* Basic Reset & Body */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body.light-mode { background: linear-gradient(to right, hsl(0,70%,20%), hsl(60,70%,20%)); color: #ddd; }
    body.dark-mode { background: linear-gradient(to right, hsl(240,70%,10%), hsl(300,70%,10%)); color: #eee; }
    body { font-family: sans-serif; overflow: hidden; }

    /* Info Panel */
    #info {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.5); padding: 10px; z-index: 9999;
      max-width: 300px; font-size: 14px;
    }
    
    /* Orchestrator Panel */
    #orchestrator {
      position: fixed; top: 10px; left: 320px; z-index: 1000;
      display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;
    }
    .quantum-ui {
      background: rgba(0,0,0,0.9); border: 1px solid #0ff;
      border-radius: 8px; padding: 10px;
    }
    button {
      background: #0ff; color: #000; border: none; cursor: pointer;
      margin-top: 5px; padding: 5px 10px; border-radius: 5px;
    }
    input[type=range] { width: 100%; margin-top: 5px; }
    
    /* New: Background Gradient Control & Optimize Button */
    #bgGradientControl {
      position: fixed; top: 50px; left: 10px; z-index: 11000;
      background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; color: #fff;
      font-size: 14px;
    }
    #bgGradientSlider { width: 200px; }
    #optimizeBtn {
      position: fixed; top: 90px; left: 10px; z-index: 11000;
      background: #0ff; color: #000; border: none; padding: 5px 10px;
      border-radius: 5px; cursor: pointer;
    }

    /* VR Button, FPS Counter, Stats */
    #vrButton {
      position: absolute; right: 10px; top: 10px; z-index: 10000;
      background: #333; color: #fff; border: 1px solid #777; padding: 5px 10px;
    }
    #fpsCounter {
      position: absolute; bottom: 10px; left: 10px; z-index: 10001;
      background: rgba(0,0,0,0.6); padding: 5px; color: lime; font-size: 12px;
    }
    #stats {
      position: absolute; top: 10px; right: 10px; z-index: 99999;
      background: rgba(0,0,0,0.8); color: #0ff; padding: 10px;
      border-radius: 5px; font-family: monospace;
    }

    /* Canvas Layers */
    canvas { position: fixed; top: 0; left: 0; }
    #fractalCanvas { z-index: 1; }
    #quantumCanvas { z-index: 2; pointer-events: none; }

    /* Dashboard Popup */
    .popup {
      display: none; position: fixed; top: 0; left: 0;
      width: 100%; height: 100%; background: rgba(0,0,0,0.5);
      z-index: 1000; overflow-y: auto;
    }
    .popup-content {
      background: #fff; margin: 5% auto; padding: 20px;
      width: 90%; max-width: 1200px; border-radius: 10px;
      position: relative;
    }
    .close-button {
      position: absolute; top: 5px; left: 5px;
      font-size: 25px; cursor: pointer; background: #e74c3c;
      color: #fff; border: none; border-radius: 5px; padding: 5px 10px;
    }
    .mode-switch {
      position: absolute; top: 10px; right: 10px;
      padding: 10px; background: #3498db; color: #fff;
      border: none; border-radius: 5px; cursor: pointer;
    }
    .dashboard {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;
    }
    .card {
      border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      transition: transform 0.3s ease, background 0.3s;
    }
    .card:hover { transform: translateY(-5px); }

    /* "What's New" Popup */
    #whatsNewPopup {
      display: none; position: fixed; top: 0; left: 0;
      width: 100%; height: 100%; background: rgba(0,0,0,0.7);
      z-index: 11000; justify-content: center; align-items: center;
    }
    #whatsNewPopup .close-popup {
      position: absolute; top: 10px; right: 10px;
      background: #e74c3c; color: #fff; border: none;
      border-radius: 50%; width: 25px; height: 25px; cursor: pointer;
    }

    /* Table of Contents Sidebar */
    #custom_tableOfContents {
      position: fixed; top: 20%; left: 0; width: 200px;
      max-height: 70%; overflow-y: auto; background: #f9f9f9;
      border-right: 1px solid #ccc; padding: 10px;
      transform: translateX(-100%); transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    #custom_tableOfContents ul { list-style: none; padding: 0; }
    #custom_tableOfContents li { margin-bottom: 5px; }
    #custom_tableOfContents a { text-decoration: none; color: #333; }
    #custom_tableOfContents a:hover { text-decoration: underline; }
    #custom_toggleButton {
      position: fixed; top: 65%; left: 0; transform: translateY(-50%);
      background: #ddd; border: 1px solid #ccc; border-radius: 0 5px 5px 0;
      cursor: pointer; padding: 5px 10px; font-size: 16px; z-index: 1001;
    }
    .custom_open #custom_toggleButton {
      left: 200px; border-radius: 5px 0 0 5px;
    }

    /* Copy Button */
    #copy-btn {
      display: none; position: fixed; top: 20px; left: 20px;
      padding: 10px 20px; border-radius: 5px; background: #007bff;
      color: #fff; border: none; cursor: pointer; z-index: 1000;
    }

    /* Typing Sparkles */
    .typing-sparkle {
      position: absolute;
      width: 8px; height: 8px;
      background: gold; border-radius: 50%;
      opacity: 0.8; pointer-events: none;
      animation: sparkle-animation 0.8s ease-out forwards;
    }
    @keyframes sparkle-animation {
      0% { transform: scale(0.5); opacity: 0.8; }
      100% { transform: scale(2); opacity: 0; }
    }

    /* Debug Panel */
    #debugOutput {
      position: fixed; bottom: 10px; right: 10px; z-index: 11000;
      background: rgba(0,0,0,0.7); color: #0f0;
      padding: 10px; max-height: 200px; overflow-y: auto;
      font-family: monospace; font-size: 12px;
      border-radius: 5px;
    }

    /* Shadow Emboss */
    .shadow-emboss {
      box-shadow: 5px 5px 15px rgba(0,0,0,0.4);
      border: 1px solid #ddd;
      transition: transform 0.3s ease;
    }
    .shadow-emboss:hover { transform: scale(1.05); }

    /* Loading Screen */
    .loading {
      display: flex; justify-content: center; align-items: center;
      height: 100vh; background: lightgray;
    }
    .loading::before {
      content: "Loading"; font-size: 36px;
      animation: loading 1s ease-in-out infinite;
    }
    @keyframes loading {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Custom Selection */
    ::selection { background: red; color: #fff; }
  </style>
</head>
<body class="light-mode">
  <!-- Loading Screen -->
  <div class="loading" id="loadingScreen"></div>

  <!-- Info Panel -->
  <div id="info">
    <b>Quantum-Fractal Nexus</b>
    <ul>
      <li>Hybrid fractal & quantum particle sim</li>
      <li>Bi-directional influence</li>
      <li>RL agent controls</li>
      <li>Toggle trails, fractal bloom, etc.</li>
      <li>Use 'w/s/a/d' & mouse drag for camera</li>
      <li>Press 'b' to toggle bloom</li>
    </ul>
  </div>

  <!-- VR Button, FPS, Stats -->
  <button id="vrButton">Enter VR</button>
  <div id="fpsCounter">FPS: 0</div>
  <div id="stats"></div>

  <!-- Orchestrator Panel -->
  <div id="orchestrator">
    <div class="quantum-ui">
      <button onclick="nexus.toggleQuantumState()">‚öõÔ∏è Quantum State</button>
      <label>Entanglement:</label>
      <input type="range" min="0" max="1" step="0.01" value="0.5" oninput="nexus.updateEntanglementStrength(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.toggleDimensionality()">üåå 4D Projection</button>
      <label>Fractal Influence:</label>
      <input type="range" min="0" max="1" step="0.1" value="0.5" oninput="nexus.setFractalInfluence(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.toggleTrails()">Toggle Trails</button>
      <label>Trail Length:</label>
      <input type="range" min="10" max="50" step="1" value="20" oninput="nexus.updateTrailLength(this.value)">
    </div>
    <div class="quantum-ui">
      <label>Particle Speed:</label>
      <input type="range" min="0.2" max="3" step="0.1" value="1" oninput="nexus.updateParticleSpeed(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.addParticles()">‚ûï Add Particles</button>
      <label>Particle Number:</label>
      <input type="range" min="100" max="1000" step="100" value="500" oninput="nexus.updateNumberOfParticles(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.resetSystem()">üåÄ Reset Nexus</button>
    </div>
  </div>

  <!-- Background Gradient Control & Optimize Simulation -->
  <div id="bgGradientControl">
    <label>Background Gradient:</label>
    <input type="range" id="bgGradientSlider" min="0" max="360" step="1" value="0" oninput="updateBackgroundGradient(this.value)">
  </div>
  <button id="optimizeBtn" onclick="optimizeSimulation()">Optimize Simulation</button>

  <!-- Dashboard Popup -->
  <div id="dashboardPopup" class="popup">
    <div class="popup-content">
      <button class="close-button" onclick="togglePopup()">Close</button>
      <button class="mode-switch" onclick="toggleMode()">üåì Toggle Dark/Light Mode</button>
      <div class="dashboard">
        <div class="card">
          <h2>System Specs</h2>
          <div id="systemSpecs"></div>
        </div>
        <div class="card">
          <h2>CPU Usage</h2>
          <canvas id="cpuChart"></canvas>
        </div>
        <div class="card">
          <h2>GPU Usage</h2>
          <canvas id="gpuChart"></canvas>
        </div>
        <div class="card">
          <h2>Memory Usage</h2>
          <canvas id="memoryChart"></canvas>
        </div>
        <div class="card">
          <h2>IP Information</h2>
          <div id="ipInfo"></div>
        </div>
        <div class="card">
          <h2>Cookie Information</h2>
          <div id="cookieInfo"></div>
          <form id="cookieForm">
            <input type="text" id="cookieName" placeholder="Cookie Name" required>
            <input type="text" id="cookieValue" placeholder="Cookie Value" required>
            <input type="number" id="cookieExpiration" placeholder="Expiration (days)" required>
            <button type="submit">Set Cookie</button>
          </form>
        </div>
        <div class="card">
          <h2>User Agent</h2>
          <div id="userAgent"></div>
        </div>
        <div class="card" id="batteryCard">
          <h2>Battery Information</h2>
          <div id="batteryInfo" style="display: flex; align-items: center; justify-content: space-between;">
            <div id="batteryLevel" style="flex-grow: 1; height: 20px; background: #ecf0f1; border-radius: 10px; overflow: hidden; margin-right: 10px;">
              <div id="batteryLevelFill" style="height: 100%; background: #27ae60; transition: width 0.5s;"></div>
            </div>
            <span id="batteryPercentage"></span>
          </div>
          <p id="batteryStatus"></p>
        </div>
      </div>
    </div>
  </div>

  <!-- "What's New" Popup -->
  <div id="whatsNewPopup">
    <div style="background: #fff; padding: 20px; border-radius: 8px; max-width: 400px; text-align: center; position: relative;">
      <button class="close-popup">&times;</button>
      <h2>What's New</h2>
      <p>
        Welcome to the latest version of Quantum-Fractal Nexus!<br>
        - All previous features remain intact.<br>
        - Advanced VR, mobile touch & sound visualizer integration.<br>
        - New settings panel with exportable state and interactive debug console.<br>
        - Dynamic background gradient & simulation optimizer.<br>
        - Live debug console output for RL agents and performance metrics.
      </p>
    </div>
  </div>

  <!-- Table of Contents Sidebar -->
  <div id="custom_tableOfContents">
    <h4>Contents</h4>
    <ul id="custom_tocList"></ul>
  </div>
  <div id="custom_toggleButton">&gt;</div>

  <!-- Copy Button -->
  <button id="copy-btn">Copy</button>

  <!-- Chat Widget -->
  <div id="chat-toggle" onclick="toggleChat()">üÜò</div>
  <div id="chat-container">
    <div id="chat-header">Help Chat</div>
    <div id="chat-body"></div>
    <div id="chat-footer">
      <input type="text" id="user-input" placeholder="Type your message...">
      <button onclick="sendMessage()">Send</button>
    </div>
  </div>

  <!-- Debug Panel -->
  <div id="debugOutput"></div>

  <!-- Canvases -->
  <canvas id="fractalCanvas"></canvas>
  <canvas id="quantumCanvas"></canvas>

  <!-- Advanced Nexus Script -->
  <script>
    /**************************************************************************
     * Quantum-Fractal Nexus - Advanced Optimized & Innovated
     *************************************************************************/
    // Utility: 3x3 Matrix Helper
    const mat3 = (a00,a01,a02, a10,a11,a12, a20,a21,a22) => [a00,a01,a02,a10,a11,a12,a20,a21,a22];

    /********** Typing Sparkles Effect **********/
    const showTypingSparkles = (e) => {
      for(let i = 0; i < 3; i++){
        const rect = e.target.getBoundingClientRect();
        const sparkle = document.createElement('div');
        sparkle.className = 'typing-sparkle';
        const randomX = rect.left + Math.random() * rect.width;
        sparkle.style.left = randomX + 'px';
        sparkle.style.top = (rect.top - 10) + 'px';
        document.body.appendChild(sparkle);
        sparkle.addEventListener('animationend', () => sparkle.remove());
      }
    };
    document.addEventListener("DOMContentLoaded", () => {
      document.querySelectorAll('input[type="text"], input[type="email"], textarea')
        .forEach(input => input.addEventListener('input', showTypingSparkles));
    });

    /********** Debug Logging **********/
    const logDebug = (msg) => {
      const debugDiv = document.getElementById("debugOutput");
      const p = document.createElement("p");
      p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      debugDiv.appendChild(p);
      debugDiv.scrollTop = debugDiv.scrollHeight;
    };

    /********** RL Agents & Particle Classes **********/
    class SimpleGNN {
      constructor() {
        this.W = [
          [Math.random()*0.1 - 0.05, Math.random()*0.1 - 0.05],
          [Math.random()*0.1 - 0.05, Math.random()*0.1 - 0.05]
        ];
        this.lr = 0.001;
      }
      forward(a, b) {
        const x = [[a, 0], [0, b]];
        const agg = [x[0][0] + x[1][0], x[0][1] + x[1][1]];
        return [
          [agg[0]*this.W[0][0] + agg[1]*this.W[1][0],
           agg[0]*this.W[0][1] + agg[1]*this.W[1][1]],
          [agg[0]*this.W[0][0] + agg[1]*this.W[1][0],
           agg[0]*this.W[0][1] + agg[1]*this.W[1][1]]
        ];
      }
    }
    class FractalAgent {
      constructor() {
        this.gnn = new SimpleGNN();
        this.epsilon = 0.1;
        this.powerOffset = 0.0;
        this.paletteIndex = 0;
        this.action = 0;
        this.qValues = [];
      }
      computeQValues(n0, n1) {
        const qvals = [];
        for(let i = 0; i < 9; i++){
          qvals.push(n0[0] + n1[0]*(i*0.5) + n0[1]*(i*0.33) + n1[1]*0.1);
        }
        return qvals;
      }
      step(audioLevel) {
        const [n0, n1] = this.gnn.forward(audioLevel, this.powerOffset);
        const qValues = this.computeQValues(n0, n1);
        const action = (Math.random() < this.epsilon) ? Math.floor(Math.random()*9) : qValues.indexOf(Math.max(...qValues));
        this.powerOffset += [-0.05, 0, 0.05][action % 3];
        this.paletteIndex = Math.floor(action / 3);
        this.action = action;
        this.qValues = qValues;
        logDebug(`FractalAgent: action=${action}, powerOffset=${this.powerOffset.toFixed(3)}`);
        return { action, qValues };
      }
      updateQ(action, qValues, reward) {
        const error = reward - qValues[action];
        for(let i = 0; i < 2; i++){
          for(let j = 0; j < 2; j++){
            this.gnn.W[i][j] += error * this.gnn.lr;
          }
        }
        logDebug(`FractalAgent updated Q with reward ${reward.toFixed(3)}`);
      }
    }
    class CameraAgent {
      constructor() {
        this.gnn = new SimpleGNN();
        this.epsilon = 0.1;
        this.action = 0;
        this.qValues = [];
      }
      computeQValues(n0, n1) {
        const qvals = [];
        for(let i = 0; i < 5; i++){
          qvals.push(n0[0] + n1[1]*i*0.1 + n0[1]*i*0.05 + n1[0]*0.2);
        }
        return qvals;
      }
      step(audioLevel, rotX, rotY) {
        const [n0, n1] = this.gnn.forward(audioLevel, (rotX + rotY) * 0.1);
        const qValues = this.computeQValues(n0, n1);
        const action = (Math.random() < this.epsilon) ? Math.floor(Math.random()*5) : qValues.indexOf(Math.max(...qValues));
        this.action = action;
        this.qValues = qValues;
        logDebug(`CameraAgent: action=${action}`);
        return { action, qValues };
      }
      updateQ(action, qValues, reward) {
        const error = reward - qValues[action];
        for(let i = 0; i < 2; i++){
          for(let j = 0; j < 2; j++){
            this.gnn.W[i][j] += error * this.gnn.lr;
          }
        }
        logDebug(`CameraAgent updated Q with reward ${reward.toFixed(3)}`);
      }
    }
    class HybridParticle {
      constructor(x, y, speed) {
        this.position = [x, y];
        this.velocity = [(Math.random()-0.5)*speed, (Math.random()-0.5)*speed];
        this.history = [];
        this.entangledWith = null;
        this.quantumState = Math.random() > 0.5;
        this.fractalCharge = 0;
      }
      update(delta, fractalParams) {
        if(this.quantumState){
          this.position[0] += this.velocity[0] * delta * fractalParams.zoom;
          this.position[1] += this.velocity[1] * delta * fractalParams.zoom;
        }
        this.fractalCharge = Math.sin(fractalParams.powerOffset * 10) * 0.1;
        this.history.push([...this.position]);
        if(this.history.length > 50) this.history.shift();
      }
      draw(ctx, showQuantum) {
        ctx.beginPath();
        ctx.arc(this.position[0], this.position[1], 3, 0, Math.PI*2);
        ctx.fillStyle = showQuantum ? `hsla(${this.fractalCharge*360},70%,50%,0.8)` : `rgba(255,255,255,0.8)`;
        ctx.fill();
      }
      drawTrail(ctx) {
        this.history.forEach((pos,i) => {
          ctx.beginPath();
          ctx.arc(pos[0], pos[1], (i/this.history.length)*2, 0, Math.PI*2);
          ctx.fillStyle = `rgba(100,200,255,${0.1 + i/this.history.length*0.3})`;
          ctx.fill();
        });
      }
    }

    /********** QuantumFractalNexus Class **********/
    class QuantumFractalNexus {
      constructor() {
        this.lastFrame = performance.now();
        this.fps = 0;
        this.lastTime = performance.now();
        this.startTime = Date.now();
        this.audioLevel = 0;
        this.rotX = 0.3;
        this.rotY = 0.6;
        this.camForward = 0;
        this.camStrafe = 0;
        this.bloomEnabled = 1;
        this.quantumState = true;
        this.fractalInfluence = 0.5;
        this.entanglementStrength = 0.5;
        this.showTrails = true;
        this.trailLength = 20;
        this.numberOfParticles = 500;
        this.baseSpeed = 1;

        // New: Additional parameter for sound visualizer overlay
        this.visualizerEnabled = true;

        // Initialize systems
        this.initQuantumSystem();
        this.initFractalSystem();
        this.initRLAgents();
        this.bindEvents();
        logDebug("QuantumFractalNexus initialized (advanced level).");
      }
      
      /* ---------- Quantum System ---------- */
      initQuantumSystem() {
        this.quantumCanvas = document.getElementById("quantumCanvas");
        this.qctx = this.quantumCanvas.getContext("2d");
        this.quantumCanvas.width = window.innerWidth;
        this.quantumCanvas.height = window.innerHeight;
        this.particles = [];
        this.createParticles(this.numberOfParticles);
      }
      createParticles(count) {
        this.particles = [];
        for(let i = 0; i < count; i++){
          const x = Math.random() * this.quantumCanvas.width;
          const y = Math.random() * this.quantumCanvas.height;
          const p = new HybridParticle(x, y, this.baseSpeed);
          p.history = Array.from({length: this.trailLength}, () => [...p.position]);
          this.particles.push(p);
        }
      }
      addParticles() { this.createParticles(Math.min(this.particles.length + 100, this.numberOfParticles)); }
      updateNumberOfParticles(val) { this.numberOfParticles = parseInt(val); this.createParticles(this.numberOfParticles); }

      /* ---------- Fractal System ---------- */
      initFractalSystem() {
        this.fractalCanvas = document.getElementById("fractalCanvas");
        this.gl = this.fractalCanvas.getContext("webgl");
        if(!this.gl){ alert("WebGL not supported!"); return; }
        this.fractalCanvas.width = window.innerWidth;
        this.fractalCanvas.height = window.innerHeight;
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        this.initShaders();
        this.initBuffers();
        this.fractalParams = { powerOffset: 0, zoom: 1.0, bloom: true };
        this.mouseDown = false;
        this.lastX = 0;
        this.lastY = 0;
      }
      initShaders() {
        const vsSource = `
          attribute vec2 a_position;
          varying vec2 v_uv;
          void main(){
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
        const fsSource = `
          precision highp float;
          varying vec2 v_uv;
          uniform vec2 u_resolution;
          uniform float u_time;
          uniform float u_audioLevel;
          uniform mat3 u_cameraMatrix;
          uniform float u_zoom;
          uniform float u_powerOffset;
          uniform int u_paletteIndex;
          uniform sampler2D u_quantumTexture;
          uniform float u_fractalInfluence;
          float hash(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233)))*43758.5453123); }
          float dither(vec2 uv){ vec2 pf = floor(uv*2.0); float pattern = mod(pf.x + pf.y*2.0, 4.0); return (pattern+0.5)/4.0; }
          vec2 mandelbulbDistanceIter(vec3 pos, float power){
            vec3 z = pos; float dr = 1.0; float r = length(z); float iterCount = 0.0;
            for(int i=0;i<10;i++){
              if(r > 2.0) break;
              iterCount = float(i);
              float theta = acos(z.z/r); float phi = atan(z.y, z.x);
              float zr = pow(r, power);
              theta *= power; phi *= power;
              z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) + pos;
              r = length(z); dr = pow(r, power-1.0)*power*dr+1.0;
            }
            return vec2(0.5 * log(r) * r / dr, iterCount);
          }
          float hybridDE(vec3 p, float power, float blendFactor){
            vec2 mb = mandelbulbDistanceIter(p, power);
            return mix(mb.x, 0.1, blendFactor);
          }
          vec2 raymarch(vec3 ro, vec3 rd, float power, float blendFactor){
            float dist = 0.0; float iterCount = 0.0;
            for(int i=0;i<200;i++){
              vec3 p = ro + rd*dist;
              float d = hybridDE(p, power, blendFactor);
              iterCount = float(i);
              if(d < 0.0005) return vec2(dist, iterCount);
              dist += d;
              if(dist > 10.0) break;
            }
            return vec2(-1.0, iterCount);
          }
          vec3 toneMap(vec3 color){ return color/(color+vec3(1.0)); }
          void main(){
            vec2 uv = v_uv;
            float time = u_time;
            vec3 ro = vec3(0.0, 0.0, 4.0 + u_zoom);
            ro = u_cameraMatrix * ro;
            vec3 forward = u_cameraMatrix * vec3(0.0, 0.0, -1.0);
            vec3 right = u_cameraMatrix * vec3(1.0, 0.0, 0.0);
            vec3 up = u_cameraMatrix * vec3(0.0, 1.0, 0.0);
            vec2 uvC = uv - 0.5; uvC.x *= (u_resolution.x/u_resolution.y);
            vec3 rd = normalize(uvC.x*right + uvC.y*up + forward);
            float power = 8.0 + u_audioLevel * 0.5 + u_powerOffset;
            float blendFactor = clamp(u_audioLevel*0.5, 0.0, 1.0);
            vec2 rm = raymarch(ro, rd, power, blendFactor);
            vec3 color = (rm.x > 0.0) ? vec3(0.2, 0.3, 0.6) : mix(vec3(0.01,0.02,0.05), vec3(0.0,0.0,0.1), uv.y);
            color += (dither(gl_FragCoord.xy)-0.5)*0.01;
            gl_FragColor = vec4(toneMap(color), 1.0);
          }
        `;
        this.mainProgram = this.createProgram(vsSource, fsSource);
        this.gl.useProgram(this.mainProgram);
        this.u_resolution_main = this.gl.getUniformLocation(this.mainProgram, "u_resolution");
        this.u_time_main = this.gl.getUniformLocation(this.mainProgram, "u_time");
        this.u_audioLevel_main = this.gl.getUniformLocation(this.mainProgram, "u_audioLevel");
        this.u_cameraMatrix_main = this.gl.getUniformLocation(this.mainProgram, "u_cameraMatrix");
        this.u_zoom_main = this.gl.getUniformLocation(this.mainProgram, "u_zoom");
        this.u_powerOffset_main = this.gl.getUniformLocation(this.mainProgram, "u_powerOffset");
        this.u_paletteIndex_main = this.gl.getUniformLocation(this.mainProgram, "u_paletteIndex");
        this.u_quantumTexture_main = this.gl.getUniformLocation(this.mainProgram, "u_quantumTexture");
        this.u_fractalInfluence_main = this.gl.getUniformLocation(this.mainProgram, "u_fractalInfluence");
      }
      createShader(type, src) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      createProgram(vsSrc, fsSrc) {
        const vs = this.createShader(this.gl.VERTEX_SHADER, vsSrc);
        const fs = this.createShader(this.gl.FRAGMENT_SHADER, fsSrc);
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
          console.error("Program link error:", this.gl.getProgramInfoLog(prog));
          this.gl.deleteProgram(prog);
          return null;
        }
        return prog;
      }
      initBuffers() {
        this.initAudio();
        this.fractalCanvas.addEventListener("mousedown", (e) => {
          this.mouseDown = true;
          this.lastX = e.clientX;
          this.lastY = e.clientY;
        });
        window.addEventListener("mouseup", () => this.mouseDown = false);
        window.addEventListener("mousemove", (e) => {
          if(!this.mouseDown) return;
          const dx = (e.clientX - this.lastX) * 0.005;
          const dy = (e.clientY - this.lastY) * 0.005;
          this.rotX += dy;
          this.rotY += dx;
          this.lastX = e.clientX;
          this.lastY = e.clientY;
        });
        window.addEventListener("resize", () => {
          this.quantumCanvas.width = window.innerWidth;
          this.quantumCanvas.height = window.innerHeight;
          this.fractalCanvas.width = window.innerWidth;
          this.fractalCanvas.height = window.innerHeight;
          this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
        });
        document.getElementById("vrButton").addEventListener("click", async () => {
          if(navigator.xr) {
            try { await navigator.xr.requestSession("immersive-vr"); alert("VR session started (advanced mode)"); }
            catch(e){ alert("Failed to start VR: " + e); }
          } else { alert("WebXR not supported in this browser"); }
        });
        window.addEventListener("keydown", (e) => {
          if(e.key === "b") this.bloomEnabled = (this.bloomEnabled > 0.5) ? 0.0 : 1.0;
          if(e.key === "w") this.camForward = 1;
          if(e.key === "s") this.camForward = -1;
          if(e.key === "a") this.camStrafe = -1;
          if(e.key === "d") this.camStrafe = 1;
        });
        window.addEventListener("keyup", (e) => {
          if(["w","s"].includes(e.key)) this.camForward = 0;
          if(["a","d"].includes(e.key)) this.camStrafe = 0;
        });
        // Mobile touch gesture support
        let lastTouchDist = null;
        window.addEventListener("touchmove", (e) => {
          if(e.touches.length === 2){
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(lastTouchDist){
              const delta = dist - lastTouchDist;
              this.fractalParams.zoom -= delta * 0.005;
            }
            lastTouchDist = dist;
          }
        });
        window.addEventListener("touchend", () => { lastTouchDist = null; });
      }
      initAudio() {
        navigator.mediaDevices.getUserMedia({audio:true})
          .then(stream => {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioCtx.createAnalyser();
            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const getAudioData = () => {
              analyser.getByteFrequencyData(dataArray);
              let avg = 0;
              for(let i = 0; i < bufferLength; i++){
                avg += dataArray[i];
              }
              avg /= bufferLength;
              this.audioLevel = avg / 255.0;
              requestAnimationFrame(getAudioData);
            };
            getAudioData();
          })
          .catch(err => { console.error("Audio error:", err); });
      }
      initRLAgents() {
        this.fractalAgent = new FractalAgent();
        this.cameraAgent  = new CameraAgent();
        this.replayBufferFA = [];
        this.replayBufferCA = [];
        this.MAX_REPLAY = 1000;
        for(let i = 0; i < 50; i++){
          const randAudio = Math.random();
          const fa = this.fractalAgent.step(randAudio);
          this.fractalAgent.updateQ(fa.action, fa.qValues, 0);
          const ca = this.cameraAgent.step(randAudio, this.rotX, this.rotY);
          this.cameraAgent.updateQ(ca.action, ca.qValues, 0);
        }
        try { this.loadState(); } catch(e){ logDebug("Load state error: " + e); }
      }
      loadState() {
        const storedFA = localStorage.getItem("fractalAgent");
        if(storedFA) {
          const faData = JSON.parse(storedFA);
          this.fractalAgent.powerOffset = faData.powerOffset;
          this.fractalAgent.paletteIndex = faData.paletteIndex;
          this.fractalAgent.epsilon = faData.epsilon;
          this.fractalAgent.gnn.W = faData.W;
        }
        const storedCA = localStorage.getItem("cameraAgent");
        if(storedCA) {
          const caData = JSON.parse(storedCA);
          this.cameraAgent.epsilon = caData.epsilon;
          this.cameraAgent.gnn.W = caData.W;
        }
      }
      saveState() {
        const faData = {
          powerOffset: this.fractalAgent.powerOffset,
          paletteIndex: this.fractalAgent.paletteIndex,
          epsilon: this.fractalAgent.epsilon,
          W: this.fractalAgent.gnn.W
        };
        localStorage.setItem("fractalAgent", JSON.stringify(faData));
        const caData = { epsilon: this.cameraAgent.epsilon, W: this.cameraAgent.gnn.W };
        localStorage.setItem("cameraAgent", JSON.stringify(caData));
      }
      addToReplayFA(state, action, reward) {
        this.replayBufferFA.push({ state, action, reward });
        if(this.replayBufferFA.length > this.MAX_REPLAY) this.replayBufferFA.shift();
      }
      addToReplayCA(state, action, reward) {
        this.replayBufferCA.push({ state, action, reward });
        if(this.replayBufferCA.length > this.MAX_REPLAY) this.replayBufferCA.shift();
      }
      replayTraining(agent, buffer) {
        for(let i = 0; i < 10; i++){
          if(buffer.length < 10) break;
          const idx = Math.floor(Math.random() * buffer.length);
          const sample = buffer[idx];
          if(agent === this.fractalAgent) {
            const [n0, n1] = this.fractalAgent.gnn.forward(sample.state.audio, sample.state.powerOffset);
            const qv = this.fractalAgent.computeQValues(n0, n1);
            this.fractalAgent.updateQ(sample.action, qv, sample.reward);
          } else {
            const [n0, n1] = this.cameraAgent.gnn.forward(sample.state.audio, sample.state.angle);
            const qv = this.cameraAgent.computeQValues(n0, n1);
            this.cameraAgent.updateQ(sample.action, qv, sample.reward);
          }
        }
      }
      runFrame() {
        const now = performance.now();
        const delta = (now - this.lastFrame) / 1000;
        this.fps = 1000 / (now - (this.lastTime || now));
        this.lastFrame = now;
        this.lastTime = now;
        this.updateQuantum(delta);
        this.updateFractal(delta);
        this.updateRLAgents(delta);
        this.renderQuantum();
        this.updateStats();
        this.saveState();
        logDebug(`Frame rendered. Delta: ${delta.toFixed(3)} s`);
        // Use requestIdleCallback if available for non-critical tasks
        if(window.requestIdleCallback) {
          requestIdleCallback(() => {});
        }
        requestAnimationFrame(() => this.runFrame());
      }
      updateQuantum(delta) {
        this.particles.forEach(p => {
          p.update(delta, this.fractalParams);
          if(p.position[0] < 0 || p.position[0] > this.quantumCanvas.width)
            p.velocity[0] *= -1;
          if(p.position[1] < 0 || p.position[1] > this.quantumCanvas.height)
            p.velocity[1] *= -1;
        });
      }
      updateFractal(delta) {
        const time = (Date.now() - this.startTime) * 0.001;
        const gl = this.gl;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(this.mainProgram);
        gl.uniform2f(this.u_resolution_main, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform1f(this.u_time_main, time);
        gl.uniform1f(this.u_audioLevel_main, this.audioLevel);
        const cosY = Math.cos(this.rotY), sinY = Math.sin(this.rotY);
        const matY = mat3(cosY, 0, -sinY, 0, 1, 0, sinY, 0, cosY);
        const cx = Math.cos(this.rotX), sx = Math.sin(this.rotX);
        const matX = mat3(1, 0, 0, 0, cx, -sx, 0, sx, cx);
        const fm = new Float32Array(9);
        for(let i = 0; i < 9; i++){
          fm[i] = matX[i] * matY[i];
        }
        gl.uniformMatrix3fv(this.u_cameraMatrix_main, false, fm);
        if(this.fractalAgent.powerOffset > 2) this.fractalAgent.powerOffset = 2;
        if(this.fractalAgent.powerOffset < -2) this.fractalAgent.powerOffset = -2;
        gl.uniform1f(this.u_powerOffset_main, this.fractalAgent.powerOffset);
        gl.uniform1i(this.u_paletteIndex_main, this.fractalAgent.paletteIndex);
        gl.uniform1f(this.u_fractalInfluence_main, this.fractalInfluence);
        const qt = this.createQuantumTexture();
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, qt);
        gl.uniform1i(this.u_quantumTexture_main, 2);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        const complexity = this.audioLevel * (this.fractalAgent.paletteIndex + 1);
        const fractalReward = (complexity > 0.5 && this.audioLevel > 0.5) ? 0.1 : -0.01;
        this.fractalAgent.updateQ(this.fractalAgent.action, this.fractalAgent.qValues, fractalReward);
        this.addToReplayFA({ audio: this.audioLevel, powerOffset: this.fractalAgent.powerOffset },
                            this.fractalAgent.action, fractalReward);
        const cameraReward = complexity * 0.05;
        this.cameraAgent.updateQ(this.cameraAgent.action, this.cameraAgent.qValues, cameraReward);
        this.addToReplayCA({ audio: this.audioLevel, angle: (this.rotX+this.rotY)*0.1 },
                            this.cameraAgent.action, cameraReward);
        if(Math.random() < 0.01){
          this.replayTraining(this.fractalAgent, this.replayBufferFA);
          this.replayTraining(this.cameraAgent, this.replayBufferCA);
        }
        this.fractalParams.zoom += this.camForward * 0.01;
        this.rotY += this.camStrafe * 0.01;
      }
      createQuantumTexture() {
        const tex = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.quantumCanvas);
        return tex;
      }
      updateRLAgents(delta) {
        const fa = this.fractalAgent.step(this.audioLevel);
        this.fractalAgent.action = fa.action;
        this.fractalAgent.qValues = fa.qValues;
        const ca = this.cameraAgent.step(this.audioLevel, this.rotX, this.rotY);
        this.cameraAgent.action = ca.action;
        this.cameraAgent.qValues = ca.qValues;
      }
      renderQuantum() {
        this.qctx.fillStyle = "rgba(0,0,0,0.1)";
        this.qctx.fillRect(0, 0, this.quantumCanvas.width, this.quantumCanvas.height);
        this.particles.forEach(p => {
          if(this.showTrails) p.drawTrail(this.qctx);
          p.draw(this.qctx, this.quantumState);
        });
        // Additional: Sound Visualizer Overlay
        if(this.visualizerEnabled) {
          this.drawAudioVisualizer();
        }
      }
      drawAudioVisualizer() {
        const ctx = this.qctx;
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = "#ff0";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const step = this.quantumCanvas.width / 100;
        for(let x = 0; x < this.quantumCanvas.width; x += step) {
          const y = this.quantumCanvas.height/2 + Math.sin(x * 0.05 + performance.now()*0.005) * this.audioLevel * 50;
          ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
      }
      updateStats() {
        document.getElementById("fpsCounter").textContent = "FPS: " + this.fps.toFixed(1);
        const entangledCount = this.particles.filter(p => p.entangledWith).length / 2;
        document.getElementById("stats").innerHTML = `Particles: ${this.particles.length}<br>FPS: ${this.fps.toFixed(1)}<br>Entanglements: ${entangledCount}`;
      }
      // Public toggles and update functions
      toggleQuantumState() { this.quantumState = !this.quantumState; }
      updateEntanglementStrength(val) { this.entanglementStrength = parseFloat(val); }
      setFractalInfluence(val) { this.fractalInfluence = parseFloat(val); }
      toggleDimensionality() { this.fourDimensional = !this.fourDimensional; }
      toggleTrails() { this.showTrails = !this.showTrails; }
      updateTrailLength(val) {
        this.trailLength = parseInt(val);
        this.particles.forEach(p => p.history = Array.from({length: this.trailLength}, () => [...p.position]));
      }
      updateParticleSpeed(val) {
        this.baseSpeed = parseFloat(val);
        this.particles.forEach(p => {
          p.velocity[0] = (Math.random()-0.5)*2*this.baseSpeed;
          p.velocity[1] = (Math.random()-0.5)*2*this.baseSpeed;
        });
      }
      resetSystem() {
        this.particles = [];
        this.createParticles(this.numberOfParticles);
        this.fractalParams.powerOffset = 0;
        this.rotX = 0.3; this.rotY = 0.6;
        this.bloomEnabled = 1;
        this.camForward = 0; this.camStrafe = 0;
      }
      runFrame() {
        const now = performance.now();
        const delta = (now - this.lastFrame) / 1000;
        this.fps = 1000 / (now - (this.lastTime || now));
        this.lastFrame = now;
        this.lastTime = now;
        this.updateQuantum(delta);
        this.updateFractal(delta);
        this.updateRLAgents(delta);
        this.renderQuantum();
        this.updateStats();
        this.saveState();
        logDebug(`Frame rendered. Delta: ${delta.toFixed(3)} s`);
        if(window.requestIdleCallback) {
          requestIdleCallback(() => {});
        }
        requestAnimationFrame(() => this.runFrame());
      }
      bindEvents() { this.initBuffers(); }
    }

    /********** Instantiate and Run Nexus **********/
    window.onload = () => {
      window.nexus = new QuantumFractalNexus();
      nexus.runFrame();
    };

    /********** Additional Utilities **********/
    // Table of Contents
    document.addEventListener("DOMContentLoaded", () => {
      const tocContainer = document.getElementById("custom_tocList");
      const headings = document.querySelectorAll("h1, h2, h3, h4, h5, h6");
      headings.forEach((heading, index) => {
        const anchor = "custom_toc" + index;
        heading.id = anchor;
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = "#" + anchor;
        a.textContent = heading.textContent;
        li.appendChild(a);
        li.style.marginLeft = (parseInt(heading.tagName.substring(1)) * 10) + "px";
        tocContainer.appendChild(li);
      });
    });
    document.getElementById("custom_toggleButton").addEventListener("click", function() {
      const toc = document.getElementById("custom_tableOfContents");
      if(toc.style.transform === "translateX(0%)") {
        toc.style.transform = "translateX(-100%)";
        this.innerHTML = "&gt;";
      } else {
        toc.style.transform = "translateX(0%)";
        this.innerHTML = "&lt;";
      }
    });
    // Copy Button
    document.addEventListener('selectionchange', () => {
      const copyBtn = document.getElementById("copy-btn");
      copyBtn.style.display = (document.getSelection().toString().length > 0) ? 'block' : 'none';
    });
    document.getElementById("copy-btn").addEventListener("click", () => {
      document.execCommand('copy');
    });
    // Chat Widget
    function toggleChat() {
      const chatContainer = document.getElementById('chat-container');
      chatContainer.style.display = (chatContainer.style.display === 'none' || chatContainer.style.display === '') ? 'block' : 'none';
    }
    function sendMessage() {
      const userInput = document.getElementById('user-input').value.toLowerCase();
      const chatBody = document.getElementById('chat-body');
      chatBody.innerHTML += `<div>User: ${userInput}</div>`;
      let reply = "I'm sorry, I don't understand. Could you please rephrase?";
      if(userInput.includes("hello")) { reply = "Hi there! How can I assist you?"; }
      else if(userInput.includes("help")) { reply = "Sure, what do you need help with?"; }
      else if(userInput.includes("bye")) { reply = "Goodbye! Have a great day!"; }
      chatBody.innerHTML += `<div>Bot: ${reply}</div>`;
      document.getElementById('user-input').value = '';
      chatBody.scrollTop = chatBody.scrollHeight;
    }
    // "What's New" Popup
    document.addEventListener("DOMContentLoaded", () => {
      if(localStorage.getItem("whatsNewSeen") !== "true") {
        document.getElementById("whatsNewPopup").style.display = "flex";
      }
      document.querySelector("#whatsNewPopup .close-popup")?.addEventListener("click", () => {
        document.getElementById("whatsNewPopup").style.display = "none";
        localStorage.setItem("whatsNewSeen", "true");
      });
    });
    // Dashboard Popup & Mode Toggle
    function togglePopup() {
      const popup = document.getElementById('dashboardPopup');
      popup.style.display = (popup.style.display === 'none' || popup.style.display === '') ? 'block' : 'none';
    }
    function toggleMode() {
      document.body.classList.toggle('dark-mode');
      document.body.classList.toggle('light-mode');
      const popupContent = document.querySelector('.popup-content');
      popupContent.style.backgroundColor = document.body.classList.contains('dark-mode') ? '#333' : '#fff';
    }
    // Background Gradient
    function updateBackgroundGradient(val) {
      document.body.style.background = `linear-gradient(to right, hsl(${val},70%,20%), hsl(${(parseInt(val)+60)%360},70%,20%))`;
      logDebug(`Background gradient updated to hue ${val}`);
    }
    // Optimize Simulation
    function optimizeSimulation() {
      nexus.updateParticleSpeed(1.5);
      nexus.updateTrailLength(30);
      logDebug("Simulation optimized: Particle speed set to 1.5, Trail length set to 30");
      alert("Simulation optimized!");
    }

    /********** Additional Optimizations **********/
    window.addEventListener("keydown", (event) => {
      if(event.keyCode == 83 && (navigator.platform.match("Mac") ? event.metaKey : event.ctrlKey)) {
        event.preventDefault();
        console.log("CTRL+S/CMD+S is blocked");
      }
    }, false);
    setTimeout(() => { document.getElementById("loadingScreen").style.display = "none"; }, 1000);
  </script>

  <!-- Debug Panel -->
  <div id="debugOutput"></div>
  
  <!-- Table of Contents Sidebar -->
  <div id="custom_tableOfContents">
    <h4>Contents</h4>
    <ul id="custom_tocList"></ul>
  </div>
  <div id="custom_toggleButton">&gt;</div>
  
  <!-- Copy Button -->
  <button id="copy-btn">Copy</button>
  
  <!-- Chat Widget -->
  <div id="chat-toggle" onclick="toggleChat()">üÜò</div>
  <div id="chat-container">
    <div id="chat-header">Help Chat</div>
    <div id="chat-body"></div>
    <div id="chat-footer">
      <input type="text" id="user-input" placeholder="Type your message...">
      <button onclick="sendMessage()">Send</button>
    </div>
  </div>
  
  <!-- Canvases -->
  <canvas id="fractalCanvas"></canvas>
  <canvas id="quantumCanvas"></canvas>
</body>
</html>
