<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum-Fractal Nexus - Single Script Fixed</title>
  <style>
    /* Minimal styling for demo; adapt as needed. */
    body {
      margin: 0; 
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      color: #fff;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      z-index: 9999;
      max-width: 300px;
      font-size: 14px;
    }
    #orchestrator {
      position: fixed;
      top: 10px;
      left: 320px;
      z-index: 1000;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    .quantum-ui {
      background: rgba(0,0,0,0.9);
      border: 1px solid #0ff;
      border-radius: 8px;
      padding: 10px;
    }
    canvas {
      position: fixed;
      top: 0; left: 0;
    }
    #quantumCanvas {
      z-index: 2;
      pointer-events: none;
    }
    #fractalCanvas {
      z-index: 1;
    }
    button {
      background: #0ff; 
      color: #000; 
      border: none; 
      cursor: pointer; 
      margin-top: 5px; 
      padding: 5px 10px;
      border-radius: 5px;
    }
    input[type=range] {
      width: 100%;
      margin: 5px 0 0 0;
    }
    #vrButton {
      position: absolute;
      right: 10px; 
      top: 10px;
      z-index: 10000;
      background: #333;
      color: #fff;
      border: 1px solid #777;
    }
    #fpsCounter {
      position: absolute;
      bottom: 10px; 
      left: 10px; 
      z-index: 10001; 
      background: rgba(0,0,0,0.6); 
      padding: 5px; 
      color: lime;
      font-size: 12px;
    }
    #stats {
      position: absolute; 
      top: 10px; 
      right: 10px; 
      z-index: 99999;
      background: rgba(0,0,0,0.8);
      color: #0ff;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <!-- Info Panel -->
  <div id="info">
    <b>Quantum-Fractal Nexus</b>
    <ul>
      <li>Hybrid fractal & quantum particle sim</li>
      <li>Bi-directional influence</li>
      <li>RL agent controls</li>
      <li>Toggle trails, fractal bloom, etc.</li>
      <li>Use 'w/s/a/d' & mouse drag for camera</li>
      <li>Press 'b' to toggle bloom</li>
    </ul>
  </div>

  <!-- Buttons / Sliders -->
  <button id="vrButton">Enter VR</button>
  <div id="fpsCounter">FPS: 0</div>
  <div id="orchestrator">
    <div class="quantum-ui">
      <button onclick="nexus.toggleQuantumState()">‚öõÔ∏è Quantum State</button>
      <label>Entanglement:</label>
      <input type="range" min="0" max="1" step="0.01" value="0.5" oninput="nexus.updateEntanglementStrength(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.toggleDimensionality()">üåå 4D Projection</button>
      <label>Fractal Influence:</label>
      <input type="range" min="0" max="1" step="0.1" value="0.5" oninput="nexus.setFractalInfluence(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.toggleTrails()">Toggle Trails</button>
      <label>Trail Length:</label>
      <input type="range" min="10" max="50" step="1" value="20" oninput="nexus.updateTrailLength(this.value)">
    </div>
    <div class="quantum-ui">
      <label>Particle Speed:</label>
      <input type="range" min="0.2" max="3" step="0.1" value="1" oninput="nexus.updateParticleSpeed(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.addParticles()">‚ûï Add Particles</button>
      <label>Particle Number:</label>
      <input type="range" min="100" max="1000" step="100" value="500" oninput="nexus.updateNumberOfParticles(this.value)">
    </div>
    <div class="quantum-ui">
      <button onclick="nexus.resetSystem()">üåÄ Reset Nexus</button>
    </div>
  </div>

  <!-- Stats Panel -->
  <div id="stats"></div>

  <!-- Canvases -->
  <canvas id="fractalCanvas"></canvas>
  <canvas id="quantumCanvas"></canvas>

  <script>
    /**************************************************************************
     *  FULL PYTHON SNIPPET (comment) as requested
     *  (This won't run in the browser; it's just here for completeness.)
     **************************************************************************
    /*
    import maya.cmds as cmds
    import json
    import os
    import numpy as np

    class HeuristicMeshReduction:
        def __init__(self, mesh_name, target_face_count):
            self.mesh_name = mesh_name
            self.target_face_count = target_face_count

        def extract_mesh_features(self):
            face_count = cmds.polyEvaluate(self.mesh_name, face=True)
            edge_count = cmds.polyEvaluate(self.mesh_name, edge=True)
            uv_count = len(cmds.polyListComponentConversion(self.mesh_name, tuv=True))
            print("Mesh features:", face_count, edge_count, uv_count)
            return face_count, edge_count, uv_count

        def compute_heuristic(self, face_count, edge_count, uv_count):
            return (face_count + edge_count*0.5 + uv_count*0.2) / self.target_face_count

        def reduce_mesh(self):
            face_count, edge_count, uv_count = self.extract_mesh_features()
            ratio = self.compute_heuristic(face_count, edge_count, uv_count)
            print("Reduction ratio:", ratio)
            # In real code: cmds.polyReduce(self.mesh_name, percentage=ratio*100)
            return ratio
    */
    /**************************************************************************/

    /**************************************************************************
     *  JS Classes & Code
     **************************************************************************/
    class SimpleGNN {
      constructor(numNodes=2) {
        this.W = [
          [Math.random()*0.1 - 0.05, Math.random()*0.1 - 0.05],
          [Math.random()*0.1 - 0.05, Math.random()*0.1 - 0.05]
        ];
        this.lr = 0.001;
      }
      forward(a, b) {
        // Very simplistic adjacency logic
        let x = [[a, 0],[0, b]];
        let x0_agg = [x[0][0] + x[1][0], x[0][1] + x[1][1]];
        let x1_agg = [x[0][0] + x[1][0], x[0][1] + x[1][1]];
        let n0 = [
          x0_agg[0]*this.W[0][0] + x0_agg[1]*this.W[1][0],
          x0_agg[0]*this.W[0][1] + x0_agg[1]*this.W[1][1]
        ];
        let n1 = [
          x1_agg[0]*this.W[0][0] + x1_agg[1]*this.W[1][0],
          x1_agg[0]*this.W[0][1] + x1_agg[1]*this.W[1][1]
        ];
        return [n0, n1];
      }
    }

    class FractalAgent {
      constructor() {
        this.gnn = new SimpleGNN();
        this.epsilon = 0.1;
        this.powerOffset = 0.0;
        this.paletteIndex = 0;
        this.action = 0;
        this.qValues = 0;
      }
      computeQValues(n0, n1) {
        let qvals = [];
        for(let i=0; i<9; i++){
          qvals.push( n0[0] + n1[0]*(i*0.5) + n0[1]*(i*0.33) + n1[1]*0.1 );
        }
        return qvals;
      }
      step(audioLevel) {
        let [n0, n1] = this.gnn.forward(audioLevel, this.powerOffset);
        let qValues = this.computeQValues(n0, n1);
        let action;
        if(Math.random() < this.epsilon){
          action = Math.floor(Math.random()*9);
        } else {
          action = qValues.indexOf(Math.max(...qValues));
        }
        let paletteI = Math.floor(action/3);
        let offsetI = action % 3;
        let offsets = [-0.05, 0.0, 0.05];
        this.powerOffset += offsets[offsetI];
        this.paletteIndex = paletteI;
        return { action, qValues };
      }
      updateQ(action, qValues, reward) {
        let error = reward - qValues[action];
        for(let i=0; i<2; i++){
          for(let j=0; j<2; j++){
            this.gnn.W[i][j] += error*this.gnn.lr;
          }
        }
      }
    }

    class CameraAgent {
      constructor() {
        this.gnn = new SimpleGNN();
        this.epsilon = 0.1;
        this.action = 0;
        this.qValues = 0;
      }
      computeQValues(n0,n1) {
        let qvals=[];
        for(let i=0; i<5; i++){
          qvals.push(n0[0] + n1[1]*i*0.1 + n0[1]*i*0.05 + n1[0]*0.2);
        }
        return qvals;
      }
      step(audioLevel, rotX, rotY) {
        let [n0,n1] = this.gnn.forward(audioLevel, (rotX+rotY)*0.1);
        let qValues = this.computeQValues(n0,n1);
        let action;
        if(Math.random() < this.epsilon) {
          action = Math.floor(Math.random()*5);
        } else {
          action = qValues.indexOf(Math.max(...qValues));
        }
        return { action, qValues };
      }
      updateQ(action, qValues, reward) {
        let error = reward - qValues[action];
        for(let i=0; i<2; i++){
          for(let j=0; j<2; j++){
            this.gnn.W[i][j] += error*this.gnn.lr;
          }
        }
      }
    }

    class HybridParticle {
      constructor(x, y, speed) {
        this.position = [x,y];
        this.velocity = [(Math.random()-0.5)*speed, (Math.random()-0.5)*speed];
        this.history = [];
        this.entangledWith = null;
        this.quantumState = Math.random()>0.5;
        this.fractalCharge = 0;
      }
      update(delta, fractalParams) {
        if(this.quantumState){
          // Move slightly scaled by fractal zoom
          this.position[0] += this.velocity[0]*delta*fractalParams.zoom;
          this.position[1] += this.velocity[1]*delta*fractalParams.zoom;
        }
        // Just for color/visual
        this.fractalCharge = Math.sin(fractalParams.powerOffset*10)*0.1;
        this.history.push([...this.position]);
        if(this.history.length>50) this.history.shift();
      }
      draw(ctx, showQuantum) {
        ctx.beginPath();
        ctx.arc(this.position[0], this.position[1], 3, 0, Math.PI*2);
        ctx.fillStyle = showQuantum ? 
          `hsla(${this.fractalCharge*360}, 70%, 50%, 0.8)` : 
          `rgba(255,255,255,0.8)`;
        ctx.fill();
      }
      drawTrail(ctx){
        this.history.forEach((pos,i)=>{
          ctx.beginPath();
          ctx.arc(pos[0], pos[1], (i/this.history.length)*2, 0, Math.PI*2);
          ctx.fillStyle = `rgba(100,200,255,${0.1 + i/this.history.length*0.3})`;
          ctx.fill();
        });
      }
    }

    /**************************************************************************
     * Main Nexus class
     **************************************************************************/
    class QuantumFractalNexus {
      constructor() {
        this.lastFrame = performance.now();
        this.fps = 0;
        this.lastTime = performance.now();
        this.startTime = Date.now();

        // In-house values
        this.entanglementStrength = 0.5;
        this.fractalInfluence = 0.5;
        this.showTrails = true;
        this.quantumState = true;

        // 1) init quantum
        this.initQuantumSystem();

        // 2) init fractal
        this.initFractalSystem();

        // Influence from fractal to quantum
        this.influenceMatrix = { fractalToQuantum: 1 };

        // RL Agents
        this.initRLAgents();

        // Events
        this.bindEvents();
      }

      /********** QUANTUM SYSTEM **********/
      initQuantumSystem() {
        this.quantumCanvas = document.getElementById("quantumCanvas");
        this.qctx = this.quantumCanvas.getContext("2d");
        this.quantumCanvas.width = window.innerWidth;
        this.quantumCanvas.height = window.innerHeight;

        this.particles = [];
        this.trailLength = 20;
        this.numberOfParticles = 500;
        this.baseSpeed = 1;
        this.createParticles(this.numberOfParticles);
      }
      createParticles(count) {
        this.particles = [];
        for(let i=0; i<count; i++){
          const x = Math.random()*this.quantumCanvas.width;
          const y = Math.random()*this.quantumCanvas.height;
          const p = new HybridParticle(x,y,this.baseSpeed);
          p.history = new Array(this.trailLength).fill().map(()=>[...p.position]);
          this.particles.push(p);
        }
      }
      addParticles() {
        const current = this.particles.length;
        const needed = Math.min(100, this.numberOfParticles - current);
        this.createParticles(current+needed);
      }
      updateNumberOfParticles(val) {
        this.numberOfParticles = parseInt(val);
        this.createParticles(this.numberOfParticles);
      }

      /********** FRACTAL SYSTEM **********/
      initFractalSystem() {
        this.fractalCanvas = document.getElementById("fractalCanvas");
        // Setup WebGL
        this.initWebGL();
        this.initShaders();
        this.initBuffers();

        // Fractal params
        this.fractalParams = {
          powerOffset: 0,
          paletteIndex: 0,
          zoom: 1.0,
          bloom: true
        };

        // Camera rotation
        this.mouseDown = false;
        this.lastX = 0;
        this.lastY = 0;
        this.rotX = 0.3;
        this.rotY = 0.6;

        // Additional camera fields
        this.bloomEnabled = 1;
        this.camForward = 0;
        this.camStrafe = 0;
      }
      initWebGL() {
        this.gl = this.fractalCanvas.getContext("webgl");
        if(!this.gl){
          alert("WebGL not supported!");
          return;
        }
        this.fractalCanvas.width = window.innerWidth;
        this.fractalCanvas.height = window.innerHeight;
        this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
      }

      initShaders() {
        // We'll remove the #define lines and replace with const int/float
        const vertexShaderSource = `
          attribute vec2 a_position;
          varying vec2 v_uv;
          void main(){
            v_uv = (a_position * 0.5) + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;

        // Replacing #define with constants
        const fragmentShaderSource = `
          precision highp float;

          // We'll define them as constants:
          const int MAX_MARCH_STEPS = 400;
          const float MAX_DISTANCE = 10.0;
          const float SURF_DISTANCE = 0.0002;
          const int LIGHT_STEPS = 10;
          const float DITHER_SCALE = 0.5;

          varying vec2 v_uv;
          uniform vec2 u_resolution;
          uniform float u_time;
          uniform float u_audioLevel;
          uniform mat3 u_cameraMatrix;
          uniform float u_zoom;
          uniform float u_powerOffset;
          uniform int u_paletteIndex;
          uniform sampler2D u_quantumTexture;
          uniform float u_fractalInfluence;

          float hash(vec2 p){
            return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453123);
          }
          float dither(vec2 uv){
            vec2 pf = floor(uv*2.0);
            float pattern = mod(pf.x + pf.y*2.0, 4.0);
            return (pattern+0.5)/4.0;
          }

          // Replacing #defines with constants:
          vec2 mandelbulbDistanceIter(vec3 pos, float power){
            vec3 z = pos;
            float dr = 1.0;
            float r = length(z);
            float iterCount = 0.0;
            for(int i=0; i<10; i++){
              if(r>2.0) break;
              iterCount = float(i);
              float theta = acos(z.z/r);
              float phi = atan(z.y, z.x);
              float zr = pow(r,power);
              theta *= power;
              phi   *= power;
              z = zr*vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) + pos;
              r = length(z);
              dr = pow(r, power-1.0)*power*dr+1.0;
            }
            float dist = 0.5*log(r)*r/dr;
            return vec2(dist, iterCount);
          }

          float juliaLikeDE(vec3 p, float cPower, vec3 c){
            vec3 z = p;
            float r=0.0;
            for(int i=0; i<10; i++){
              r = dot(z,z);
              if(r>4.0) break;
              z = vec3(z.x*z.x - z.y*z.y - z.z*z.z, 2.0*z.x*z.y, 2.0*z.x*z.z) + c;
            }
            return 0.5*sqrt(r);
          }

          float hybridDE(vec3 p, float power, float blendFactor){
            vec2 mb = mandelbulbDistanceIter(p, power);
            vec3 c = vec3(sin(u_time*0.3), cos(u_time*0.3), sin(u_time*0.7)*cos(u_time*0.3))*0.5;
            float ju = juliaLikeDE(p, 2.0 + power*0.2, c);
            return mix(mb.x, ju, blendFactor);
          }

          vec3 quantumEffect(vec3 p){
            vec2 uv = gl_FragCoord.xy / u_resolution;
            vec4 qData = texture2D(u_quantumTexture, uv);
            return p*(1.0 + qData.rgb*u_fractalInfluence*0.1);
          }

          vec2 raymarch(vec3 ro, vec3 rd, float power, float blendFactor){
            float dist=0.0;
            float iterationCount=0.0;
            for(int i=0;i<MAX_MARCH_STEPS;i++){
              vec3 pp = ro + rd*dist;
              pp = quantumEffect(pp);
              vec2 dRes= mandelbulbDistanceIter(pp, power);
              iterationCount = dRes.y;
              float d = hybridDE(pp, power, blendFactor);
              if(d < SURF_DISTANCE){
                return vec2(dist, iterationCount);
              }
              dist+=d;
              if(dist>MAX_DISTANCE) break;
            }
            return vec2(-1.0, iterationCount);
          }

          float hybridDEOffset(vec3 p, float power, float blendFactor){
            return hybridDE(p, power, blendFactor);
          }

          vec3 calcNormal(vec3 p, float power, float blendFactor){
            float d = hybridDEOffset(p, power, blendFactor);
            float e=0.0005;
            float dx= hybridDEOffset(p+vec3(e,0,0), power, blendFactor)-d;
            float dy= hybridDEOffset(p+vec3(0,e,0), power, blendFactor)-d;
            float dz= hybridDEOffset(p+vec3(0,0,e), power, blendFactor)-d;
            return normalize(vec3(dx,dy,dz));
          }

          float ambientOcclusion(vec3 p, vec3 n, float power, float blendFactor){
            float ao=1.0;
            float stepSize=0.003;
            for(int i=1;i<=5;i++){
              float len = float(i)*stepSize;
              float d = hybridDEOffset(p+n*len, power, blendFactor);
              ao -= clamp((len-d)*0.5, 0.0,0.5);
            }
            return clamp(ao, 0.0,1.0);
          }

          float starField(vec2 uv, float time){
            uv*=200.0;
            vec2 iuv= floor(uv);
            float rnd= hash(iuv);
            float twinkle = 0.5 + 0.5*sin(time*10.0 + rnd*10.0);
            float star = step(0.995, rnd);
            return star*twinkle;
          }

          vec3 getPaletteColor(int idx, float iterationFactor){
            if(idx==0){
              return mix(vec3(0.2,0.3,0.6), vec3(0.0,0.7,0.9), iterationFactor);
            } else if(idx==1){
              return mix(vec3(0.6,0.2,0.2), vec3(1.0,0.5,0.2), iterationFactor);
            } else if(idx==2){
              return mix(vec3(0.2,0.4,0.2), vec3(0.6,1.0,0.5), iterationFactor);
            } else {
              return mix(vec3(0.4,0.2,0.6), vec3(0.9,0.3,1.0), iterationFactor);
            }
          }

          vec3 environmentColor(vec3 dir){
            float u= dir.y*0.5+0.5;
            return mix(vec3(0.05,0.05,0.1), vec3(0.2,0.5,0.7), u);
          }

          vec3 lighting(vec3 p, vec3 n, vec3 ro, float iteration, float power, float audioLevel, float time, int paletteIdx){
            vec3 lightDir= normalize(vec3(1.0,0.5,0.7));
            vec3 rimLightDir= normalize(vec3(-0.7,-0.4,-1.0));
            float diff = clamp(dot(n, lightDir),0.0,1.0);
            float diff2= clamp(dot(n, rimLightDir)*0.5+0.5,0.0,1.0);
            float fresnel= pow(1.0 - dot(n, normalize(ro-p)),2.0);

            vec3 baseColor= vec3(0.15,0.2,0.4)*diff + vec3(0.1)*fresnel;
            float iterationFactor = iteration/10.0;
            vec3 paletteColor = getPaletteColor(paletteIdx, iterationFactor);
            vec3 audioTint = mix(vec3(1.0), vec3(0.6,1.0,0.6), audioLevel*0.5);
            vec3 finalColor = baseColor*paletteColor*audioTint;
            finalColor += vec3(0.1,0.15,0.25)*diff2*0.3;

            float skyFactor=clamp(n.y*0.5+0.5,0.0,1.0);
            vec3 skyColor=mix(vec3(0.05,0.05,0.1),vec3(0.2,0.3,0.5),skyFactor);
            finalColor= mix(finalColor, finalColor*skyColor, 0.2);

            float reflectFactor=0.2;
            vec3 r = reflect(normalize(ro-p),n);
            vec3 reflectColor= environmentColor(r);
            finalColor= mix(finalColor, finalColor+reflectColor*0.5, reflectFactor);
            return finalColor;
          }

          float volumetricLight(vec3 pos, vec3 lightDir, float power, float blendFactor){
            float stepLen=0.02;
            float vol=0.0;
            vec3 p=pos;
            for(int i=0;i<LIGHT_STEPS;i++){
              p+=lightDir*stepLen;
              float d= hybridDEOffset(p, power, blendFactor);
              if(d<0.002){
                vol+=0.1;
              } else {
                vol*=0.95;
              }
            }
            return clamp(vol,0.0,1.0);
          }

          vec3 toneMap(vec3 color){
            color= color/(color+vec3(1.0));
            return pow(color, vec3(0.9));
          }

          void main(){
            vec2 uv = v_uv;
            float fov=1.2;
            float camDist=4.0+u_zoom;
            vec3 ro= vec3(0.0,0.0,camDist);
            ro= u_cameraMatrix*ro;
            vec3 forward= u_cameraMatrix* vec3(0.0,0.0,-1.0);
            vec3 right= u_cameraMatrix* vec3(1.0,0.0,0.0);
            vec3 up= u_cameraMatrix* vec3(0.0,1.0,0.0);

            vec2 uvC= uv-0.5;
            uvC.x*= (u_resolution.x/u_resolution.y);
            vec3 rd= normalize( uvC.x*right*fov + uvC.y*up*fov + forward );

            float timeMorph=0.5*sin(u_time*0.3)+0.5;
            float basePower=8.0 + u_audioLevel*0.5 + timeMorph*0.3;
            float power= basePower + u_powerOffset;
            float blendFactor= clamp(u_audioLevel*0.5,0.0,1.0);

            vec2 rm = raymarch(ro, rd, power, blendFactor);
            float t=rm.x;
            float iteration=rm.y;
            vec3 color;

            if(t>0.0){
              vec3 p= ro+ rd*t;
              vec3 n= calcNormal(p, power, blendFactor);
              float ao= ambientOcclusion(p,n,power,blendFactor);
              color= lighting(p,n,ro, iteration,power,u_audioLevel,u_time,u_paletteIndex);
              color*=ao;
              float particleNoise= hash(floor(p.xy*20.0+u_time*5.0));
              color+= particleNoise*0.03;
              vec3 lightDir= normalize(vec3(1.0,0.5,0.7));
              float vol= volumetricLight(p, lightDir, power, blendFactor);
              color+= vec3(vol*0.1, vol*0.08, vol*0.05);
            } else {
              // sky background
              vec3 bg= mix(vec3(0.01,0.02,0.05), vec3(0.0,0.0,0.1), uv.y);
              float sf = starField(uv, u_time);
              bg+= vec3(sf);
              float pNoise= hash(floor(uv*200.0 + u_time*2.0));
              bg+= pNoise*0.01;
              color=bg;
            }

            float grain= hash(uv* vec2(u_time*60.0, u_time*60.0))*0.02;
            color+= grain;
            color= toneMap(color);

            float d= dither(gl_FragCoord.xy);
            color+= (d-0.5)*DITHER_SCALE*0.01;

            gl_FragColor= vec4(color,1.0);
          }
        `;

        const blurVertexShaderSource = `
          attribute vec2 a_position;
          varying vec2 v_uv;
          void main(){
            v_uv = (a_position * 0.5) + 0.5;
            gl_Position = vec4(a_position,0.0,1.0);
          }
        `;
        const blurFragmentShaderSource = `
          precision highp float;
          varying vec2 v_uv;
          uniform sampler2D u_texture;
          uniform vec2 u_resolution;
          uniform vec2 u_direction;
          void main(){
            vec2 uv=v_uv;
            float sigma=3.0;
            float weightSum=0.0;
            vec3 color=vec3(0.0);
            for(float i=-4.0;i<=4.0;i++){
              float x=i;
              float w=exp(-0.5*(x*x)/(sigma*sigma));
              vec2 offset= u_direction*(x/u_resolution);
              color+= w*texture2D(u_texture, uv+offset).rgb;
              weightSum+=w;
            }
            color/=weightSum;
            gl_FragColor= vec4(color,1.0);
          }
        `;
        const compositeFragmentShaderSource = `
          precision highp float;
          varying vec2 v_uv;
          uniform sampler2D u_scene;
          uniform sampler2D u_bloom;
          uniform float u_bloomEnabled;
          void main(){
            vec3 scene = texture2D(u_scene, v_uv).rgb;
            vec3 bloom = texture2D(u_bloom, v_uv).rgb;
            vec3 finalColor= scene + bloom*u_bloomEnabled*0.7;
            gl_FragColor= vec4(finalColor,1.0);
          }
        `;

        this.mainProgram = this.createProgram(vertexShaderSource, fragmentShaderSource);
        this.blurProgram = this.createProgram(blurVertexShaderSource, blurFragmentShaderSource);
        this.compositeProgram = this.createProgram(blurVertexShaderSource, compositeFragmentShaderSource);

        // VBO
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        const positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

        // Main program
        this.gl.useProgram(this.mainProgram);
        this.a_position_main = this.gl.getAttribLocation(this.mainProgram,"a_position");
        this.gl.enableVertexAttribArray(this.a_position_main);
        this.gl.vertexAttribPointer(this.a_position_main,2,this.gl.FLOAT,false,0,0);

        // Blur program
        this.gl.useProgram(this.blurProgram);
        this.a_position_blur = this.gl.getAttribLocation(this.blurProgram,"a_position");
        this.gl.enableVertexAttribArray(this.a_position_blur);
        this.gl.vertexAttribPointer(this.a_position_blur,2,this.gl.FLOAT,false,0,0);

        // Composite program
        this.gl.useProgram(this.compositeProgram);
        this.a_position_comp = this.gl.getAttribLocation(this.compositeProgram,"a_position");
        this.gl.enableVertexAttribArray(this.a_position_comp);
        this.gl.vertexAttribPointer(this.a_position_comp,2,this.gl.FLOAT,false,0,0);

        // Uniforms (main)
        this.u_resolution_main = this.gl.getUniformLocation(this.mainProgram, "u_resolution");
        this.u_time_main = this.gl.getUniformLocation(this.mainProgram, "u_time");
        this.u_audioLevel_main = this.gl.getUniformLocation(this.mainProgram, "u_audioLevel");
        this.u_cameraMatrix_main = this.gl.getUniformLocation(this.mainProgram, "u_cameraMatrix");
        this.u_zoom_main = this.gl.getUniformLocation(this.mainProgram, "u_zoom");
        this.u_powerOffset_main = this.gl.getUniformLocation(this.mainProgram, "u_powerOffset");
        this.u_paletteIndex_main = this.gl.getUniformLocation(this.mainProgram, "u_paletteIndex");
        this.u_quantumTexture_main = this.gl.getUniformLocation(this.mainProgram, "u_quantumTexture");
        this.u_fractalInfluence_main = this.gl.getUniformLocation(this.mainProgram, "u_fractalInfluence");

        // Blur
        this.u_texture_blur = this.gl.getUniformLocation(this.blurProgram,"u_texture");
        this.u_resolution_blur = this.gl.getUniformLocation(this.blurProgram,"u_resolution");
        this.u_direction_blur = this.gl.getUniformLocation(this.blurProgram,"u_direction");

        // Composite
        this.u_scene_comp = this.gl.getUniformLocation(this.compositeProgram,"u_scene");
        this.u_bloom_comp = this.gl.getUniformLocation(this.compositeProgram,"u_bloom");
        this.u_bloomEnabled_comp = this.gl.getUniformLocation(this.compositeProgram,"u_bloomEnabled");

        // Create FBOs
        this.sceneFBO = this.createFBO(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
        this.pingFBO = this.createFBO(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
        this.pongFBO = this.createFBO(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
      }
      createShader(type, src) {
        const s = this.gl.createShader(type);
        this.gl.shaderSource(s, src);
        this.gl.compileShader(s);
        if(!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)){
          console.error(this.gl.getShaderInfoLog(s));
          this.gl.deleteShader(s);
          return null;
        }
        return s;
      }
      createProgram(vsSrc, fsSrc) {
        const vs = this.createShader(this.gl.VERTEX_SHADER, vsSrc);
        const fs = this.createShader(this.gl.FRAGMENT_SHADER, fsSrc);
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        if(!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)){
          console.error(this.gl.getProgramInfoLog(prog));
          this.gl.deleteProgram(prog);
          return null;
        }
        return prog;
      }
      createFBO(w,h){
        const fb=this.gl.createFramebuffer();
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
        const tex=this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE);
        this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,w,h,0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,null);
        const rb=this.gl.createRenderbuffer();
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, rb);
        this.gl.renderbufferStorage(this.gl.RENDERBUFFER,this.gl.DEPTH_COMPONENT16,w,h);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,tex,0);
        this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER,this.gl.DEPTH_ATTACHMENT,this.gl.RENDERBUFFER,rb);
        this.gl.bindTexture(this.gl.TEXTURE_2D,null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null);
        return {fbo:fb, tex:tex, rb:rb, w, h};
      }
      initBuffers(){
        // Audio
        this.audioLevel=0.0;
        navigator.mediaDevices.getUserMedia({audio:true})
          .then(stream=>{
            const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
            const analyser = audioCtx.createAnalyser();
            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize=256;
            const bufferLength= analyser.frequencyBinCount;
            const dataArray=new Uint8Array(bufferLength);

            const getAudioData= ()=>{
              analyser.getByteFrequencyData(dataArray);
              let avg=0;
              for(let i=0; i<bufferLength; i++){
                avg+= dataArray[i];
              }
              avg/=bufferLength;
              this.audioLevel= avg/255.0;
              requestAnimationFrame(getAudioData);
            };
            getAudioData();
          })
          .catch(err=>{ /* no audio input, ignore */ });

        // Mouse
        this.fractalCanvas.addEventListener("mousedown",(e)=>{
          this.mouseDown=true;
          this.lastX=e.clientX;
          this.lastY=e.clientY;
        });
        window.addEventListener("mouseup",()=>this.mouseDown=false);
        window.addEventListener("mousemove",(e)=>{
          if(!this.mouseDown)return;
          const dx=(e.clientX - this.lastX)*0.005;
          const dy=(e.clientY - this.lastY)*0.005;
          this.rotX+=dy;
          this.rotY+=dx;
          this.lastX=e.clientX;
          this.lastY=e.clientY;
        });
        // Resize
        window.addEventListener("resize", ()=>{
          this.quantumCanvas.width = window.innerWidth;
          this.quantumCanvas.height= window.innerHeight;
          this.fractalCanvas.width= window.innerWidth;
          this.fractalCanvas.height= window.innerHeight;
          this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
          this.sceneFBO= this.createFBO(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
          this.pingFBO= this.createFBO(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
          this.pongFBO= this.createFBO(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight);
        });

        // VR button
        document.getElementById("vrButton").addEventListener("click", async()=>{
          if(navigator.xr){
            try {
              await navigator.xr.requestSession("immersive-vr");
              alert("VR session started. (Placeholder)");
            } catch(e) {
              alert("Failed to start VR: "+e);
            }
          } else {
            alert("WebXR not supported in this browser");
          }
        });

        // Keyboard
        window.addEventListener("keydown",(e)=>{
          if(e.key==="b"){
            this.bloomEnabled = (this.bloomEnabled>0.5) ? 0.0 : 1.0;
          }
          if(e.key==="w") this.camForward=1;
          if(e.key==="s") this.camForward=-1;
          if(e.key==="a") this.camStrafe=-1;
          if(e.key==="d") this.camStrafe=1;
        });
        window.addEventListener("keyup",(e)=>{
          if(e.key==="w"|| e.key==="s") this.camForward=0;
          if(e.key==="a"|| e.key==="d") this.camStrafe=0;
        });
      }

      initRLAgents() {
        this.fractalAgent = new FractalAgent();
        this.cameraAgent  = new CameraAgent();
        this.replayBufferFA = [];
        this.replayBufferCA = [];
        this.MAX_REPLAY= 1000;
        // Minimal ‚Äúpretrain‚Äù
        this.pretrainAgents(50);
        // Attempt to load state
        try {
          this.loadState();
        } catch(e){}
      }
      loadState() {
        let storedFA= localStorage.getItem("fractalAgent");
        if(storedFA){
          let faData= JSON.parse(storedFA);
          this.fractalAgent.powerOffset= faData.powerOffset;
          this.fractalAgent.paletteIndex=faData.paletteIndex;
          this.fractalAgent.epsilon= faData.epsilon;
          this.fractalAgent.gnn.W= faData.W;
        }
        let storedCA= localStorage.getItem("cameraAgent");
        if(storedCA){
          let caData=JSON.parse(storedCA);
          this.cameraAgent.epsilon=caData.epsilon;
          this.cameraAgent.gnn.W=caData.W;
        }
      }
      saveState() {
        let faData = {
          powerOffset: this.fractalAgent.powerOffset,
          paletteIndex: this.fractalAgent.paletteIndex,
          epsilon: this.fractalAgent.epsilon,
          W: this.fractalAgent.gnn.W
        };
        localStorage.setItem("fractalAgent", JSON.stringify(faData));
        let caData = {
          epsilon: this.cameraAgent.epsilon,
          W: this.cameraAgent.gnn.W
        };
        localStorage.setItem("cameraAgent", JSON.stringify(caData));
      }
      pretrainAgents(steps=50){
        for(let i=0;i<steps;i++){
          let randAudio=Math.random();
          let fa= this.fractalAgent.step(randAudio);
          this.fractalAgent.updateQ(fa.action, fa.qValues, 0);
          let ca= this.cameraAgent.step(randAudio,this.rotX,this.rotY);
          this.cameraAgent.updateQ(ca.action, ca.qValues, 0);
        }
      }
      addToReplayFA(state,action,reward){
        this.replayBufferFA.push({state,action,reward});
        if(this.replayBufferFA.length>this.MAX_REPLAY) this.replayBufferFA.shift();
      }
      addToReplayCA(state,action,reward){
        this.replayBufferCA.push({state,action,reward});
        if(this.replayBufferCA.length>this.MAX_REPLAY) this.replayBufferCA.shift();
      }
      replayTraining(agent, buffer){
        for(let i=0; i<10; i++){
          if(buffer.length<10) break;
          let idx= Math.floor(Math.random()*buffer.length);
          let sample= buffer[idx];
          if(agent===this.fractalAgent){
            let [n0,n1]= this.fractalAgent.gnn.forward(sample.state.audio, sample.state.powerOffset);
            let qv= this.fractalAgent.computeQValues(n0,n1);
            this.fractalAgent.updateQ(sample.action,qv,sample.reward);
          } else {
            let [n0,n1]= this.cameraAgent.gnn.forward(sample.state.audio, sample.state.angle);
            let qv= this.cameraAgent.computeQValues(n0,n1);
            this.cameraAgent.updateQ(sample.action,qv,sample.reward);
          }
        }
      }

      initHybridPhysics(){ /* currently empty; called automatically */ }

      /********** Render cycle **********/
      runFrame(){
        let now= performance.now();
        let delta = (now - this.lastFrame)/1000;
        this.lastFrame= now;
        this.fps= 1000/(now-(this.lastTime||now));
        this.lastTime= now;

        // 1) quantum
        this.updateQuantum(delta);

        // 2) fractal
        this.updateFractal(delta);

        // 3) RL
        this.updateRLAgents(delta);

        // 4) draw quantum overlay
        this.renderQuantum();

        // stats
        this.updateStats();

        requestAnimationFrame(()=>this.runFrame());
      }

      updateQuantum(delta){
        this.particles.forEach(p=>{
          p.update(delta, this.fractalParams);
          this.applyFractalInfluence(p);
          this.handleEntanglement(p);
          this.constrainBounds(p);
        });
      }
      updateFractal(delta){
        let time= (Date.now()- this.startTime)*0.001;
        let gl= this.gl;

        // Scene FBO
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.sceneFBO.fbo);
        gl.viewport(0,0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT| gl.DEPTH_BUFFER_BIT);

        gl.useProgram(this.mainProgram);
        gl.uniform2f(this.u_resolution_main, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform1f(this.u_time_main, time);
        gl.uniform1f(this.u_audioLevel_main, this.audioLevel);

        let zoom= 0.5 + Math.sin(time*0.1)*0.2 + this.fractalParams.zoom;
        gl.uniform1f(this.u_zoom_main, zoom);

        // camera matrix
        let cx= Math.cos(this.rotX), sx= Math.sin(this.rotX);
        let matY= this.mat3(Math.cos(this.rotY),0,-Math.sin(this.rotY),  0,1,0,  Math.sin(this.rotY),0,Math.cos(this.rotY));
        let matX= this.mat3(1,0,0,  0,cx,-sx,  0,sx,cx);

        // multiply matX * matY
        let fm= new Float32Array(9);
        fm[0]= matX[0]*matY[0]+ matX[1]*matY[3]+ matX[2]*matY[6];
        fm[1]= matX[0]*matY[1]+ matX[1]*matY[4]+ matX[2]*matY[7];
        fm[2]= matX[0]*matY[2]+ matX[1]*matY[5]+ matX[2]*matY[8];

        fm[3]= matX[3]*matY[0]+ matX[4]*matY[3]+ matX[5]*matY[6];
        fm[4]= matX[3]*matY[1]+ matX[4]*matY[4]+ matX[5]*matY[7];
        fm[5]= matX[3]*matY[2]+ matX[4]*matY[5]+ matX[5]*matY[8];

        fm[6]= matX[6]*matY[0]+ matX[7]*matY[3]+ matX[8]*matY[6];
        fm[7]= matX[6]*matY[1]+ matX[7]*matY[4]+ matX[8]*matY[7];
        fm[8]= matX[6]*matY[2]+ matX[7]*matY[5]+ matX[8]*matY[8];

        gl.uniformMatrix3fv(this.u_cameraMatrix_main,false, fm);

        // limit fractalAgent range
        if(this.fractalAgent.powerOffset>2) this.fractalAgent.powerOffset=2;
        if(this.fractalAgent.powerOffset<-2) this.fractalAgent.powerOffset=-2;

        gl.uniform1f(this.u_powerOffset_main, this.fractalAgent.powerOffset);
        gl.uniform1i(this.u_paletteIndex_main, this.fractalAgent.paletteIndex);
        gl.uniform1f(this.u_fractalInfluence_main, this.fractalInfluence);

        const qt= this.createQuantumTexture();
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, qt);
        gl.uniform1i(this.u_quantumTexture_main, 2);

        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        // RL rewards (example)
        let complexity= this.audioLevel*(this.fractalAgent.paletteIndex+1);
        let fractalReward= (complexity>0.5 && this.audioLevel>0.5)? 0.1: -0.01;
        this.fractalAgent.updateQ(this.fractalAgent.action,this.fractalAgent.qValues,fractalReward);
        this.addToReplayFA({audio: this.audioLevel, powerOffset:this.fractalAgent.powerOffset},
                           this.fractalAgent.action, fractalReward);

        let cameraReward= complexity*0.05;
        this.cameraAgent.updateQ(this.cameraAgent.action,this.cameraAgent.qValues,cameraReward);
        this.addToReplayCA({audio:this.audioLevel, angle:(this.rotX+this.rotY)*0.1},
                           this.cameraAgent.action, cameraReward);

        if(Math.random()<0.01){
          this.replayTraining(this.fractalAgent, this.replayBufferFA);
          this.replayTraining(this.cameraAgent, this.replayBufferCA);
        }

        // ping-pong blur
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.pingFBO.fbo);
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT| gl.DEPTH_BUFFER_BIT);
        gl.useProgram(this.blurProgram);
        gl.uniform2f(this.u_resolution_blur, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform2f(this.u_direction_blur,1.0,0.0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.sceneFBO.tex);
        gl.uniform1i(this.u_texture_blur,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.pongFBO.fbo);
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT| gl.DEPTH_BUFFER_BIT);
        gl.uniform2f(this.u_direction_blur,0.0,1.0);
        gl.bindTexture(gl.TEXTURE_2D, this.pingFBO.tex);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        // Composite
        gl.bindFramebuffer(gl.FRAMEBUFFER,null);
        gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT| gl.DEPTH_BUFFER_BIT);
        gl.useProgram(this.compositeProgram);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D,this.sceneFBO.tex);
        gl.uniform1i(this.u_scene_comp,0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D,this.pongFBO.tex);
        gl.uniform1i(this.u_bloom_comp,1);
        gl.uniform1f(this.u_bloomEnabled_comp, this.bloomEnabled);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        // Save RL
        this.saveState();

        // Basic camera movement
        this.fractalParams.zoom += this.camForward*0.01;
        this.rotY += this.camStrafe*0.01;
      }
      createQuantumTexture(){
        const tex= this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,this.quantumCanvas);
        return tex;
      }

      updateRLAgents(delta){
        let fa= this.fractalAgent.step(this.audioLevel);
        this.fractalAgent.action= fa.action;
        this.fractalAgent.qValues= fa.qValues;

        let ca= this.cameraAgent.step(this.audioLevel, this.rotX, this.rotY);
        this.cameraAgent.action= ca.action;
        this.cameraAgent.qValues= ca.qValues;
      }

      renderQuantum(){
        this.qctx.fillStyle= "rgba(0,0,0,0.1)";
        this.qctx.fillRect(0,0,this.quantumCanvas.width,this.quantumCanvas.height);
        this.particles.forEach(p=>{
          if(this.showTrails) p.drawTrail(this.qctx);
          p.draw(this.qctx, this.quantumState);
        });
      }

      updateStats(){
        const fpsEl = document.getElementById("fpsCounter");
        const statsEl= document.getElementById("stats");
        fpsEl.textContent= "FPS: "+this.fps.toFixed(1);
        let entangledCount= this.particles.filter(pp=> pp.entangledWith).length/2;
        statsEl.innerHTML= `Particles: ${this.particles.length}<br>
                            FPS: ${this.fps.toFixed(1)}<br>
                            Entanglements: ${entangledCount}`;
      }

      /********** UTILS **********/
      mat3(a00,a01,a02, a10,a11,a12, a20,a21,a22){
        return [a00,a01,a02,a10,a11,a12,a20,a21,a22];
      }
      bindEvents(){
        this.initBuffers();
      }

      applyFractalInfluence(p){
        const fractalData= this.sampleFractal(p.position);
        p.velocity[0]+= fractalData.x* this.influenceMatrix.fractalToQuantum*0.1;
        p.velocity[1]+= fractalData.y* this.influenceMatrix.fractalToQuantum*0.1;
      }
      sampleFractal(pos){
        let uv={
          x: pos[0]/this.quantumCanvas.width,
          y: 1.0 - pos[1]/this.quantumCanvas.height
        };
        let pix= new Uint8Array(4);
        this.gl.readPixels(
          uv.x*this.gl.drawingBufferWidth,
          uv.y*this.gl.drawingBufferHeight,
          1,1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pix
        );
        return {
          x: (pix[0]/255 - 0.5)*2,
          y: (pix[1]/255 - 0.5)*2
        };
      }
      handleEntanglement(p1){
        if(!p1.entangledWith && Math.random()< 0.002*this.entanglementStrength){
          let p2= this.particles[Math.floor(Math.random()* this.particles.length)];
          if(p2!==p1){
            p1.entangledWith= p2;
            p2.entangledWith= p1;
          }
        }
        if(p1.entangledWith){
          const dx= p1.position[0]- p1.entangledWith.position[0];
          const dy= p1.position[1]- p1.entangledWith.position[1];
          const f= 0.0001/(dx*dx + dy*dy + 0.0001);
          p1.velocity[0]-= dx*f;
          p1.velocity[1]-= dy*f;
          p1.entangledWith.velocity[0]+= dx*f;
          p1.entangledWith.velocity[1]+= dy*f;
        }
      }
      constrainBounds(p){
        if(p.position[0]<0 || p.position[0]> this.quantumCanvas.width){
          p.velocity[0]*= -1;
        }
        if(p.position[1]<0 || p.position[1]> this.quantumCanvas.height){
          p.velocity[1]*= -1;
        }
      }

      // Public toggles
      toggleQuantumState(){
        this.quantumState= !this.quantumState;
      }
      updateEntanglementStrength(val){
        this.entanglementStrength= parseFloat(val);
      }
      setFractalInfluence(val){
        this.fractalInfluence= parseFloat(val);
      }
      toggleDimensionality(){
        this.fourDimensional= !this.fourDimensional; // purely conceptual in this example
      }
      toggleTrails(){
        this.showTrails= !this.showTrails;
      }
      updateTrailLength(val){
        this.trailLength= parseInt(val);
        this.particles.forEach(p=>p.history = new Array(this.trailLength).fill().map(()=>[...p.position]));
      }
      updateParticleSpeed(val){
        this.baseSpeed= parseFloat(val);
        this.particles.forEach(p=>{
          p.velocity[0]=(Math.random()-0.5)*2*this.baseSpeed;
          p.velocity[1]=(Math.random()-0.5)*2*this.baseSpeed;
        });
      }
      resetSystem(){
        this.particles=[];
        this.createParticles(this.numberOfParticles);
        this.fractalParams.powerOffset=0;
        this.rotX=0.3; 
        this.rotY=0.6;
        this.bloomEnabled=1;
        this.camForward=0;
        this.camStrafe=0;
      }
    }

    /**************************************************************************
     * Instantiate and run
     **************************************************************************/
    // Make "nexus" globally accessible so HTML handlers can see it:
    window.onload = () => {
      window.nexus = new QuantumFractalNexus();
      nexus.runFrame();
    };

  </script>
</body>
</html>
